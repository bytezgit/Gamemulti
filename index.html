<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Multiplayer Dots</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{overflow:hidden;touch-action:none;background:#111;font-family:sans-serif;color:#fff}
        #canvas{display:block}
        #ui{position:absolute;top:10px;left:10px;z-index:10}
        button{padding:15px 30px;margin:5px;font-size:18px;cursor:pointer}
        input{padding:15px;font-size:18px;width:220px;text-transform:uppercase}
        #info{display:none}
        #joystick{position:absolute;bottom:30px;left:30px;width:150px;height:150px;background:rgba(255,255,255,0.1);border-radius:50%;display:none}
        #stick{position:absolute;width:60px;height:60px;background:rgba(255,255,255,0.4);border-radius:50%;top:50%;left:50%;transform:translate(-50%,-50%)}
        #status{margin-top:10px;font-size:14px;color:#0f0}
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="ui">
        <div id="menu">
            <button onclick="hostGame()">HOST GAME</button><br><br>
            <input type="text" id="joinCode" placeholder="Room Code"><br>
            <button onclick="joinGame()">JOIN GAME</button>
            <div id="status"></div>
        </div>
        <div id="info">
            <div style="font-size:24px">Room: <b id="roomCode"></b></div>
            <div>Players: <span id="playerCount">1</span></div>
        </div>
    </div>
    
    <div id="joystick">
        <div id="stick"></div>
    </div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const joystickEl = document.getElementById('joystick');
const stickEl = document.getElementById('stick');
const status = document.getElementById('status');

let peer = null;
let connections = [];
let isHost = false;
let myId = Math.random().toString(36).substr(2, 9);
let myColor = ['#ff6b6b','#4ecdc4','#ffe66d','#95e1d3','#f38181','#aa96da','#fcbad3','#a8d8ea'][Math.floor(Math.random()*8)];

// Players now have: x, y (display), targetX, targetY (where they're going), vx, vy (velocity)
let players = {};
let myPos = { x: 0, y: 0 };
let velocity = { x: 0, y: 0 };
let gameStarted = false;

// Interpolation speed (higher = snappier, lower = smoother but more delay)
const LERP_SPEED = 0.2;

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    if (!gameStarted) {
        myPos.x = canvas.width / 2;
        myPos.y = canvas.height / 2;
    }
}
window.addEventListener('resize', resize);
resize();

function hostGame() {
    status.textContent = 'Creating room...';
    const roomCode = Math.random().toString(36).substr(2, 5).toUpperCase();
    
    peer = new Peer('dotgame2024-' + roomCode, { debug: 0 });
    
    peer.on('open', () => {
        isHost = true;
        gameStarted = true;
        document.getElementById('menu').style.display = 'none';
        document.getElementById('info').style.display = 'block';
        document.getElementById('roomCode').textContent = roomCode;
        joystickEl.style.display = 'block';
        players[myId] = { 
            x: myPos.x, y: myPos.y, 
            targetX: myPos.x, targetY: myPos.y,
            vx: 0, vy: 0,
            color: myColor 
        };
    });
    
    peer.on('connection', conn => {
        connections.push(conn);
        
        conn.on('open', () => {
            conn.send({ type: 'welcome', players: getPlayersData() });
        });
        
        conn.on('data', data => handleData(data, conn));
        
        conn.on('close', () => {
            connections = connections.filter(c => c !== conn);
            if (conn.playerId) {
                delete players[conn.playerId];
                broadcastPlayers();
            }
        });
    });
    
    peer.on('error', err => {
        status.textContent = 'Error: ' + err.type;
    });
}

function joinGame() {
    const roomCode = document.getElementById('joinCode').value.toUpperCase().trim();
    if (!roomCode) {
        status.textContent = 'Enter a room code!';
        return;
    }
    
    status.textContent = 'Connecting...';
    peer = new Peer(undefined, { debug: 0 });
    
    peer.on('open', () => {
        const conn = peer.connect('dotgame2024-' + roomCode, { reliable: true });
        connections.push(conn);
        
        conn.on('open', () => {
            gameStarted = true;
            document.getElementById('menu').style.display = 'none';
            document.getElementById('info').style.display = 'block';
            document.getElementById('roomCode').textContent = roomCode;
            joystickEl.style.display = 'block';
            
            conn.send({ 
                type: 'join', 
                id: myId, 
                x: myPos.x, 
                y: myPos.y, 
                vx: 0, 
                vy: 0,
                color: myColor 
            });
        });
        
        conn.on('data', data => handleData(data, conn));
    });
    
    peer.on('error', err => {
        if (err.type === 'peer-unavailable') {
            status.textContent = 'Room not found!';
        } else {
            status.textContent = 'Error: ' + err.type;
        }
    });
}

function getPlayersData() {
    let data = {};
    for (let id in players) {
        const p = players[id];
        data[id] = { x: p.x, y: p.y, vx: p.vx || 0, vy: p.vy || 0, color: p.color };
    }
    return data;
}

function handleData(data, conn) {
    if (data.type === 'welcome') {
        for (let id in data.players) {
            const p = data.players[id];
            players[id] = {
                x: p.x, y: p.y,
                targetX: p.x, targetY: p.y,
                vx: p.vx || 0, vy: p.vy || 0,
                color: p.color
            };
        }
        players[myId] = { 
            x: myPos.x, y: myPos.y, 
            targetX: myPos.x, targetY: myPos.y,
            vx: 0, vy: 0,
            color: myColor 
        };
        updatePlayerCount();
    }
    else if (data.type === 'join') {
        conn.playerId = data.id;
        players[data.id] = { 
            x: data.x, y: data.y, 
            targetX: data.x, targetY: data.y,
            vx: data.vx || 0, vy: data.vy || 0,
            color: data.color 
        };
        broadcastPlayers();
        updatePlayerCount();
    }
    else if (data.type === 'move') {
        if (players[data.id] && data.id !== myId) {
            const p = players[data.id];
            // Set target position and velocity for interpolation
            p.targetX = data.x;
            p.targetY = data.y;
            p.vx = data.vx;
            p.vy = data.vy;
        }
        if (isHost) {
            connections.forEach(c => {
                if (c !== conn && c.open) c.send(data);
            });
        }
    }
    else if (data.type === 'players') {
        for (let id in data.players) {
            if (id !== myId) {
                const p = data.players[id];
                if (!players[id]) {
                    players[id] = { 
                        x: p.x, y: p.y, 
                        targetX: p.x, targetY: p.y,
                        vx: 0, vy: 0,
                        color: p.color 
                    };
                } else {
                    players[id].targetX = p.x;
                    players[id].targetY = p.y;
                    players[id].color = p.color;
                }
            }
        }
        // Remove players not in list
        for (let id in players) {
            if (id !== myId && !data.players[id]) {
                delete players[id];
            }
        }
        updatePlayerCount();
    }
}

function broadcastPlayers() {
    const msg = { type: 'players', players: getPlayersData() };
    connections.forEach(c => {
        if (c.open) c.send(msg);
    });
    updatePlayerCount();
}

function updatePlayerCount() {
    document.getElementById('playerCount').textContent = Object.keys(players).length;
}

// Joystick
let joystickActive = false;
let joystickCenter = { x: 0, y: 0 };
let joystickTouchId = null;

joystickEl.addEventListener('touchstart', e => {
    e.preventDefault();
    const touch = e.changedTouches[0];
    joystickTouchId = touch.identifier;
    joystickActive = true;
    const rect = joystickEl.getBoundingClientRect();
    joystickCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
    handleJoystick(touch);
});

document.addEventListener('touchmove', e => {
    if (!joystickActive) return;
    for (let touch of e.changedTouches) {
        if (touch.identifier === joystickTouchId) {
            handleJoystick(touch);
            e.preventDefault();
        }
    }
}, { passive: false });

document.addEventListener('touchend', e => {
    for (let touch of e.changedTouches) {
        if (touch.identifier === joystickTouchId) {
            joystickActive = false;
            joystickTouchId = null;
            velocity = { x: 0, y: 0 };
            stickEl.style.transform = 'translate(-50%, -50%)';
        }
    }
});

function handleJoystick(touch) {
    const dx = touch.clientX - joystickCenter.x;
    const dy = touch.clientY - joystickCenter.y;
    const maxDist = 45;
    const dist = Math.min(Math.sqrt(dx*dx + dy*dy), maxDist);
    const angle = Math.atan2(dy, dx);
    
    const stickX = Math.cos(angle) * dist;
    const stickY = Math.sin(angle) * dist;
    stickEl.style.transform = `translate(calc(-50% + ${stickX}px), calc(-50% + ${stickY}px))`;
    
    const speed = 5;
    velocity.x = (dist / maxDist) * Math.cos(angle) * speed;
    velocity.y = (dist / maxDist) * Math.sin(angle) * speed;
}

// Keyboard
const keys = {};
window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; keys[e.code] = true; });
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; keys[e.code] = false; });

let lastSend = 0;

function lerp(a, b, t) {
    return a + (b - a) * t;
}

function update() {
    if (!gameStarted) return;
    
    // Keyboard input
    let kx = 0, ky = 0;
    if (keys['w'] || keys['ArrowUp']) ky = -1;
    if (keys['s'] || keys['ArrowDown']) ky = 1;
    if (keys['a'] || keys['ArrowLeft']) kx = -1;
    if (keys['d'] || keys['ArrowRight']) kx = 1;
    
    if (kx !== 0 || ky !== 0) {
        const len = Math.sqrt(kx*kx + ky*ky);
        velocity.x = (kx / len) * 5;
        velocity.y = (ky / len) * 5;
    } else if (!joystickActive) {
        velocity.x = 0;
        velocity.y = 0;
    }
    
    // Move self
    myPos.x += velocity.x;
    myPos.y += velocity.y;
    myPos.x = Math.max(25, Math.min(canvas.width - 25, myPos.x));
    myPos.y = Math.max(25, Math.min(canvas.height - 25, myPos.y));
    
    // Update my player data (no interpolation for self)
    players[myId] = { 
        x: myPos.x, y: myPos.y, 
        targetX: myPos.x, targetY: myPos.y,
        vx: velocity.x, vy: velocity.y,
        color: myColor 
    };
    
    // INTERPOLATE other players smoothly!
    for (let id in players) {
        if (id === myId) continue;
        
        const p = players[id];
        
        // Predict where they're going based on velocity
        const predictedX = p.targetX + (p.vx || 0);
        const predictedY = p.targetY + (p.vy || 0);
        
        // Smooth interpolation towards predicted position
        p.x = lerp(p.x, predictedX, LERP_SPEED);
        p.y = lerp(p.y, predictedY, LERP_SPEED);
    }
    
    // Send position at 20fps (every 50ms)
    const now = Date.now();
    if (now - lastSend > 50) {
        lastSend = now;
        const msg = { 
            type: 'move', 
            id: myId, 
            x: myPos.x, 
            y: myPos.y,
            vx: velocity.x,
            vy: velocity.y
        };
        connections.forEach(c => {
            if (c.open) c.send(msg);
        });
    }
}

function draw() {
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw all players
    for (let id in players) {
        const p = players[id];
        
        // Shadow
        ctx.beginPath();
        ctx.arc(p.x + 3, p.y + 3, 25, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fill();
        
        // Main dot
        ctx.beginPath();
        ctx.arc(p.x, p.y, 25, 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.fill();
        
        // White ring for self
        if (id === myId) {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();
        }
    }
}

function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
